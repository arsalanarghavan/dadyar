# ساختار پروژه — ریز هر فایل و پوشه

این سند وظیفه هر فایل و پوشه را توضیح می‌دهد و در حد امکان «به زبان ساده» می‌گوید آن فایل چه نقشی در برنامه دارد.

---

## ریشه پروژه (Root)

### `app.py`

- **وظیفه**: نقطه ورود اصلی **رابط کاربری** برنامه. با فریم‌ورک Streamlit تب‌ها را می‌سازد، استایل (CSS) را بارگذاری می‌کند، وضعیت جلسه (session state) را مقداردهی می‌کند و ماژول‌های مربوط به فرم، تحلیل و گراف را صدا می‌زند.
- **به زبان ساده**: همان صفحه‌ای که کاربر می‌بیند از اینجا شروع می‌شود؛ مثل «دکمه‌ها و باکس‌ها و تب‌ها» همه از این فایل و ماژول‌هایی که صدا می‌زند ساخته می‌شوند.

### `launcher.py`

- **وظیفه**: اجرای **سرور Streamlit** و باز کردن مرورگر روی آدرس localhost. در حالت عادی با subprocess سرور را اجرا می‌کند؛ وقتی برنامه با PyInstaller به صورت exe بسته شده باشد، مستقیماً از API داخلی Streamlit استفاده می‌کند. همچنین یک پورت آزاد پیدا می‌کند و در یک thread جدا بعد از بالا آمدن سرور مرورگر را باز می‌کند.
- **به زبان ساده**: وقتی دابل‌کلیک روی اجرایی یا اسکریپت می‌کنی، این فایل اول برنامه وب را روشن می‌کند و بعد مرورگر را برایت باز می‌کند تا صفحه را ببینی.

### `requirements.txt`

- **وظیفه**: لیست **کتابخانه‌های پایتون** (و در صورت مشخص بودن، نسخه آن‌ها) که برنامه به آن‌ها نیاز دارد. با دستور `pip install -r requirements.txt` همه نصب می‌شوند.
- **به زبان ساده**: فهرست «لوازم» برنامه است؛ هر کس بخواهد برنامه را اجرا کند با یک دستور همه این لوازم را نصب می‌کند.

### `install_and_run.bat`

- **وظیفه**: اسکریپت **ویندوز** برای نصب یک‌باره و اجرا. وجود پایتون را چک می‌کند، در صورت نبودن venv آن را می‌سازد، وابستگی‌ها را نصب می‌کند، در صورت نبودن `.env` از `.env.example` کپی می‌گیرد و در پایان `launcher.py` را اجرا می‌کند.
- **به زبان ساده**: یک دکمه «همه‌کار» برای ویندوز؛ با یک بار اجرا هم نصب می‌شود هم برنامه اجرا می‌شود.

### `install_and_run.sh`

- **وظیفه**: همان منطق برای **لینوکس و مک**: چک پایتون، ساخت venv، نصب وابستگی‌ها، ساخت `.env` در صورت نیاز و اجرای launcher.
- **به زبان ساده**: همان «دکمه همه‌کار» ولی برای لینوکس/مک.

### `build_windows.bat`

- **وظیفه**: ساخت **نسخه توزیعی ویندوز** با PyInstaller. فرض می‌کند venv و وابستگی‌ها از قبل نصب شده‌اند؛ PyInstaller را نصب می‌کند و با فایل `dadyar.spec` خروجی را در `dist\dadyar\` می‌سازد.
- **به زبان ساده**: برنامه را به صورت یک پوشه حاوی exe و فایل‌های لازم برای ویندوز بسته‌بندی می‌کند.

### `build_linux.sh`

- **وظیفه**: همان کار برای **لینوکس**: با PyInstaller و `dadyar.spec` خروجی در `dist/dadyar/` ساخته می‌شود.
- **به زبان ساده**: بسته‌بندی برنامه برای لینوکس.

### `dadyar.spec`

- **وظیفه**: فایل **تنظیمات PyInstaller**. مشخص می‌کند نقطه ورود `launcher.py` است، کدام فایل‌ها و پوشه‌ها (مثل `app.py`, `config`, `modules`, `data`, `assets`) داخل بسته قرار بگیرند، کدام ماژول‌ها به صورت پنهان import شوند و چه چیزهایی از بسته حذف شوند تا حجم کم شود.
- **به زبان ساده**: دستورالعمل «چطور برنامه را ببندی» برای PyInstaller.

### `.env.example`

- **وظیفه**: **نمونه** متغیرهای محیطی. شامل نام‌گذاری و مقدار پیش‌فرض برای انتخاب سرویس AI، کلیدهای API، نام مدل، تنظیمات RAG، رنگ‌ها و غیره. کاربر آن را کپی می‌کند به `.env` و مقادیر واقعی (مثل API key) را در `.env` قرار می‌دهد.
- **به زبان ساده**: یک فرم خالی تنظیمات؛ تو مقادیر واقعی را در `.env` پر می‌کنی و برنامه از آن می‌خواند.

### `.gitignore`

- **وظیفه**: به گیت می‌گوید کدام فایل‌ها و پوشه‌ها **رد شوند** (مثل `venv/`, `build/`, `dist/`, `.env`, `__pycache__/`).
- **به زبان ساده**: لیست چیزهایی که داخل مخزن نسخه‌گذاری ذخیره نمی‌شوند (مثلاً محیط مجازی و رمزها).

### `.gitattributes`

- **وظیفه**: تنظیمات **نرمال‌سازی** فایل‌ها در گیت (مثلاً تشخیص فایل‌های متنی و پایان خط).
- **به زبان ساده**: قواعد یکنواخت کردن فایل‌ها در گیت.

---

## پوشه `config/`

تنظیمات و متن‌های ثابتی که به مدل AI داده می‌شوند (پرامپت).

### `config/settings.py`

- **وظیفه**: بارگذاری **همه تنظیمات** از متغیرهای محیطی (و فایل `.env`) با استفاده از Pydantic. یک کلاس `Settings` و یک تابع `get_settings()` دارد که یک نمونه واحد (singleton) برمی‌گرداند تا در کل برنامه یک جا تنظیمات خوانده شود.
- **به زبان ساده**: مثل دفتر تنظیمات برنامه؛ همه چیز (کلید API، مدل، رنگ گراف، تعداد مواد و …) از یک جا خوانده می‌شود.

### `config/prompts.py`

- **وظیفه**: متن **پرامپتهای ثابت** برای مدل: نقش «قاضی متخصص»، دستور استخراج موجودیت از پرونده، دستور تحلیل ماده‌به‌ماده، تولید نتیجه‌گیری میانی، تولید حکم نهایی و ارزیابی اطمینان. همه به فارسی و با ساختار مشخص.
- **به زبان ساده**: متن‌هایی که به هوش مصنوعی می‌دهیم تا بداند «چطور فکر کند» و «چه جور جواب بدهد».

### `config/__init__.py`

- **وظیفه**: خالی یا حداقلی؛ باعث می‌شود پوشه `config` به عنوان یک **پکیج پایتون** شناخته شود تا بتوان با `from config.settings import ...` استفاده کرد.
- **به زبان ساده**: فقط برای این است که پایتون این پوشه را «یک بسته» بداند.

---

## پوشه `data/`

داده‌های ثابت برنامه (مواد قانون و پرونده‌های نمونه).

### `data/legal_articles.json`

- **وظیفه**: **مواد قانون مدنی** مرتبط با غصب و خلع ید (معمولاً مواد ۳۰۸ تا ۳۲۷) به صورت JSON. هر ماده شامل شماره، عنوان، متن، واژه‌های کلیدی و در صورت وجود یادداشت تفسیری است. ممکن است یک بخش `legal_concepts` هم برای مفاهیم حقوقی داشته باشد. این فایل منبع **RAG** است.
- **به زبان ساده**: کتاب کوچک قانونی که برنامه از آن مواد مرتبط را پیدا می‌کند و به مدل می‌دهد.

### `data/sample_cases.json`

- **وظیفه**: چند **پرونده نمونه** با شناسه، تاریخ، خواهان، خوانده، شرح، واقعیات، ادعاها و در صورت وجود حکم مورد انتظار. از رابط کاربری می‌توان یکی را بارگذاری کرد تا فرم پر شود.
- **به زبان ساده**: چند پرونده مثال برای تست و دمو؛ با یک کلیک می‌توانی یکی را در فرم بیاوری.

### `data/__init__.py`

- **وظیفه**: خالی یا حداقلی؛ تعریف پکیج `data`. برنامه مسیر فایل‌ها را با `Path` به `data/legal_articles.json` و `data/sample_cases.json` می‌رساند و این پکیج برای import مستقیم ماژول از داخل `data` لازم نیست؛ می‌توان نگه داشت برای سازگاری یا حذف کرد.
- **به زبان ساده**: فقط برای این که پوشه به عنوان پکیج شناخته شود؛ روی منطق برنامه اثر مستقیم ندارد.

---

## پوشه `assets/styles/`

ظاهر برنامه (راست‌به‌چپ و تم).

### `assets/styles/main.css`

- **وظیفه**: **تم اصلی** و استایل کلی: متغیرهای رنگی (تم تاریک)، فونت (مثلاً Vazirmatn از Google Fonts)، استایل المان‌های Streamlit، کارت‌ها، دکمه‌ها و فاصله‌ها.
- **به زبان ساده**: تعیین رنگ‌ها و شکل کلی صفحه.

### `assets/styles/rtl.css`

- **وظیفه**: استایل‌های **راست‌به‌چپ (RTL)** و موارد خاص **فارسی** تا متن و چیدمان درست نمایش داده شوند.
- **به زبان ساده**: تنظیم جهت صفحه و متن برای فارسی.

---

## پوشه `modules/`

منطق برنامه و قطعات رابط کاربری.

### `modules/__init__.py`

- **وظیفه**: خالی یا حداقلی؛ تعریف پکیج `modules`.
- **به زبان ساده**: فقط برای شناخته شدن پوشه به عنوان پکیج.

---

## پوشه `modules/legal_engine/`

موتور حقوقی: ارتباط با AI، پایگاه دانش قانون، استخراج موجودیت، استدلال و حکم.

### `modules/legal_engine/base_client.py`

- **وظیفه**: **کلاس پایه** برای کلاینت مدل زبانی (LLM). متدهای مشترک (مثل chat، embedding) و در صورت وجود **کش** برای پاسخ‌ها تعریف می‌کند تا فراخوانی تکراری به API کم شود.
- **به زبان ساده**: قالب مشترک برای «حرف زدن با OpenAI یا Gemini»؛ هر دو سرویس از این قالب پیروی می‌کنند.

### `modules/legal_engine/openai_client.py`

- **وظیفه**: **پیاده‌سازی** کلاینت برای **OpenAI**: فراخوانی API چت و در صورت استفاده، embedding. از تنظیمات (مثل `OPENAI_API_KEY`, `OPENAI_MODEL`) استفاده می‌کند.
- **به زبان ساده**: قسمت برنامه که مستقیم با سرویس OpenAI صحبت می‌کند.

### `modules/legal_engine/gemini_client.py`

- **وظیفه**: **پیاده‌سازی** کلاینت برای **Google Gemini**: چت و در صورت نیاز embedding با API مربوط به Gemini.
- **به زبان ساده**: قسمت برنامه که با سرویس Gemini صحبت می‌کند.

### `modules/legal_engine/client_factory.py`

- **وظیفه**: بر اساس تنظیمات یا انتخاب کاربر در **سایدبار** (OpenAI یا Gemini)، نمونه **درست** کلاینت را می‌سازد و برمی‌گرداند. در صورت عوض شدن provider یا مدل، نمونه قبلی کنار گذاشته و نمونه جدید ساخته می‌شود؛ همچنین سینگلتون‌های وابسته (مثل entity extractor، reasoning engine، verdict generator و در صورت وجود کش knowledge base) ریست می‌شوند.
- **به زبان ساده**: تصمیم می‌گیرد «الان با OpenAI حرف بزنیم یا با Gemini» و همان را آماده می‌کند.

### `modules/legal_engine/knowledge_base.py`

- **وظیفه**: **بارگذاری** مواد از `data/legal_articles.json`، ساخت مدل **TF-IDF** روی متن مواد و **جستجوی شباهت** (مثلاً cosine) برای بازیابی مواد مرتبط با شرح پرونده. می‌تواند جستجوی ترکیبی (معنایی + کلیدواژه) هم داشته باشد. همه محاسبات **محلی** است و برای بازیابی مواد به API مدل نیاز ندارد.
- **به زبان ساده**: مغز «کتاب قانون» برنامه؛ وقتی متن پرونده را می‌گیرد، مواد مرتبط را پیدا می‌کند و به مدل می‌دهد تا جواب دقیق‌تر باشد (RAG).

### `modules/legal_engine/entity_extractor.py`

- **وظیفه**: با استفاده از **مدل زبانی** و یک پرامپت ثابت، از **متن پرونده** اطلاعات ساخت‌یافته استخراج می‌کند: خواهان، خوانده، نوع پرونده، نوع مال، تاریخ وقوع، ادعاها، شواهد و واقعیات کلیدی. خروجی با **Pydantic** اعتبارسنجی می‌شود (مثلاً کلاس `CaseEntities`).
- **به زبان ساده**: از پاراگراف پرونده، نام طرفین و واقعیت‌های مهم را بیرون می‌کشد و به صورت مرتب برمی‌گرداند.

### `modules/legal_engine/reasoning_engine.py`

- **وظیفه**: **قلب منطق** تحلیل. با استفاده از Knowledge Base مواد مرتبط را بازیابی می‌کند، برای هر ماده (یا به صورت کلی) با مدل **تحلیل applicability** می‌گیرد، **نتیجه‌گیری‌های میانی** تولید می‌کند و یک زنجیره **ReasoningStep** (نوع: FACT, ARTICLE, DEDUCTION, VERDICT) و در نهایت یک **ReasoningResult** می‌سازد که به گراف و حکم خوراک می‌دهد.
- **به زبان ساده**: هماهنگ‌کننده اصلی؛ مواد را می‌گیرد، به مدل می‌دهد، استدلال قدم‌به‌قدم می‌سازد و نتیجه را برای گراف و حکم آماده می‌کند.

### `modules/legal_engine/verdict_generator.py`

- **وظیفه**: روی خروجی **ReasoningResult** یک **پرامپت حکم** می‌سازد و با مدل متن **حکم نهایی** را تولید می‌کند؛ خروجی ساخت‌یافته (خلاصه، واقعیات اثبات‌شده، تحلیل حقوقی، ruling، قابلیت اعتراض و در صورت وجود اطمینان) در یک ساختار مثل `Verdict` برمی‌گردد.
- **به زبان ساده**: از زنجیره استدلال، متن رسمی «حکم» را می‌نویسد و به کاربر نشان می‌دهد.

### `modules/legal_engine/__init__.py`

- **وظیفه**: خالی یا حداقلی؛ تعریف پکیج `legal_engine`.
- **به زبان ساده**: فقط برای import کردن از `modules.legal_engine`.

---

## پوشه `modules/graph_builder/`

ساخت و نمایش گراف استدلال.

### `modules/graph_builder/reasoning_graph.py`

- **وظیفه**: از **ReasoningResult** یک **گراف جهت‌دار** با NetworkX می‌سازد: گره‌های نوع FACT، ARTICLE، DEDUCTION و VERDICT و یال‌های بین آن‌ها تا جریان استدلال (واقعیت‌ها → مواد → نتیجه‌گیری‌ها → حکم) نمایش داده شود. رنگ و برچسب گره‌ها از تنظیمات خوانده می‌شود.
- **به زبان ساده**: استدلال را به صورت «نقشه گره و خط» در می‌آورد تا در مرحله بعد با Plotly کشیده شود.

### `modules/graph_builder/plotly_renderer.py`

- **وظیفه**: گراف NetworkX را می‌گیرد و با **Plotly** آن را به یک نمودار تعاملی (و در صورت نیاز تصویر ثابت) تبدیل می‌کند تا در رابط Streamlit نمایش داده شود.
- **به زبان ساده**: همان گراف را روی صفحه وب رسم می‌کند تا کاربر ببیند.

### `modules/graph_builder/__init__.py`

- **وظیفه**: خالی یا حداقلی؛ تعریف پکیج `graph_builder`.
- **به زبان ساده**: فقط برای import.

---

## پوشه `modules/ui_components/`

قطعات رابط کاربری: فرم، سایدبار، نمایش تحلیل و گراف.

### `modules/ui_components/sidebar.py`

- **وظیفه**: رسم **نوار کناری** Streamlit: انتخاب سرویس AI (OpenAI/Gemini)، انتخاب مدل و در صورت وجود پرونده جاری نمایش خلاصه (شناسه، تاریخ، طرفین). در صورت تغییر provider ممکن است تابع ریست کلاینت صدا زده شود.
- **به زبان ساده**: منوی کنار صفحه که با آن مدل و تنظیمات را عوض می‌کنی و خلاصه پرونده را می‌بینی.

### `modules/ui_components/input_form.py`

- **وظیفه**: **فرم ورودی** پرونده: فیلدهای شناسه، تاریخ، خواهان، خوانده و شرح پرونده؛ دکمه ارسال و در صورت وجود دکمه «بارگذاری پرونده نمونه» از `data/sample_cases.json`. اعتبارسنجی حداقلی (مثلاً حداقل طول شرح) و برگرداندن یک دیکشنری `case_data` برای ذخیره در session و استفاده در تب تحلیل.
- **به زبان ساده**: همان فرمی که کاربر پرونده را در آن وارد می‌کند و یک پرونده نمونه را می‌توان با یک کلیک لود کرد.

### `modules/ui_components/analysis_view.py`

- **وظیفه**: وقتی پرونده جاری در session وجود دارد، **استخراج موجودیت**، **تحلیل (reasoning)** و **تولید حکم** را فراخوانی می‌کند و نتیجه را (تحلیل گام‌به‌گام، مواد، اطمینان و متن حکم) نمایش می‌دهد. ممکن است نتیجه برای جلوگیری از محاسبه دوباره در session کش شود و داده گراف برای تب گراف در session ذخیره شود.
- **به زبان ساده**: تب «تحلیل قضایی»؛ همان جایی که نتیجه استخراج، استدلال و حکم را می‌بینی.

### `modules/ui_components/graph_view.py`

- **وظیفه**: داده گراف ذخیره‌شده در session را می‌گیرد، در صورت نیاز با **ReasoningGraph** و **Plotly renderer** گراف را می‌سازد و در صفحه **نمایش** می‌دهد. اگر هنوز تحلیلی انجام نشده باشد پیام راهنما نشان می‌دهد.
- **به زبان ساده**: تب «گراف استدلال»؛ نمودار واقعیت‌ها و مواد و نتیجه و حکم را نشان می‌دهد.

### `modules/ui_components/persian_utils.py`

- **وظیفه**: توابع کمکی برای **متن و تاریخ فارسی**: تبدیل اعداد به فارسی/لاتین، فرمت تاریخ شمسی (با jdatetime)، بسته‌کردن متن در تگ RTL و در صورت استفاده نرمال‌سازی با Hazm. یک سینگلتون مثل `get_persian_utils()` برای استفاده در کل UI.
- **به زبان ساده**: ابزارهای کوچک برای درست نشان دادن تاریخ و عدد و جهت متن به فارسی.

### `modules/ui_components/__init__.py`

- **وظیفه**: معمولاً export نام ماژول‌های sidebar، input_form، analysis_view، graph_view تا در `app.py` با یک import بتوان آن‌ها را فراخوانی کرد.
- **به زبان ساده**: درگاه واحد برای استفاده از تمام قطعات UI در صفحه اصلی.

---

## پوشه `tests/`

- **وظیفه**: در حال حاضر فقط `__init__.py` دارد؛ برای **تست‌های واحد یا یکپارچگی** در آینده.
- **به زبان ساده**: جای تست‌های خودکار که بعداً اضافه می‌شوند.

---

برای دیدن **معماری کلی** و **جریان داده** به [ARCHITECTURE.md](ARCHITECTURE.md) و برای **معنی اصطلاحات** به [GLOSSARY.md](GLOSSARY.md) مراجعه کن.
